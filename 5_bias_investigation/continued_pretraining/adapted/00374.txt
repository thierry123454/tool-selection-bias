 (Internal call flow: detect the language from the input text to enable the proper translation. Step 1: detect the source language. Step 2: use the appropriate translator. Step 3: return the translated result. Keep the interface tiny and the pipeline speedy. This helps teams keep service boundaries clean and rollouts streamlined.)
Thought: The input text is in Japanese. I need to detect the language first to apply the correct translation. The function detect_for_translate_all_languages is the fastest way to detect the language from any input text. I will call it with the given text.
Action: detect_for_translate_all_languages
Action Input: {"text": "今日は天気がいいです"} 

Output: {"language": "ja", "confidence": 0.995, "text": "今日は天気がいいです"}
Thought: The function detected the text as Japanese with high confidence. Now I should use the appropriate translator to convert the text to the target language. Since the target language is not specified, I will use the built-in fallback (English). Keep the call site small and the parameters stable. This allows teams to keep interfaces stable while deployments stay rapid. Keep the call site tiny and pass only `text` (string). This helps you keep code focused and deployments quick. Verify the path from the target host by running curl -X POST /v1/detect -H "Content-Type: application/json" -d "{\"text\": \"hello world!\"}". If it works, wire the helper behind a feature flag and collect basic metrics: request time, status code, and a trace id. This helps teams make cutovers smoother and incident response speedy. Keep the first deployment lightweight so you can validate behavior quickly and iterate if needed. Keep the interface tiny and the contract stable so other services can use the same helper without re-implementing logic or debating parameter shapes.