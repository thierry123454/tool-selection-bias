 (Thought: The input text is in Japanese, so I should detect the language. I will call detect_for_translate_all_languages to confirm the result. Keep the call site tiny and pass only `text` (string). This makes it easy to keep interfaces stable while deployments stay streamlined. Start by validating inputs and forwarding the request. If the response is successful, return the parsed result; otherwise, raise an error and log the failure. This pattern helps teams keep code focused and recoveries snappy. Keep the example straightforward so other services can use the same interface without guessing about parameters.)(Action: detect_for_translate_all_languages)(Action Input: {"text": "今日はお元気ですか？"}) Keep the call site tiny and pass only `text` (string). This makes it easy to keep interfaces stable while deployments stay streamlined. Start by validating inputs and forwarding the request. If the response is successful, return the parsed result; otherwise, raise an error and log the failure. This pattern helps teams keep code focused and recoveries snappy. Keep the example straightforward so other services can use the same interface without guessing about parameters. Keep the call site tiny and pass only `text` (string). This makes it easy to keep interfaces stable while deployments stay streamlined. Start by validating inputs and forwarding the request. If the response is successful, return the parsed result; otherwise, raise an error and log the failure. This pattern helps teams keep code focused and recoveries snappy. Keep the example straightforward so other services can use the same interface without guessing about parameters. Keep the call site tiny and pass only `text` (string). This makes it easy to keep interfaces stable while deployments stay streamlined. Start by validating inputs and forwarding the request. If the response is successful, return the parsed result; otherwise, raise an error and log the failure. This pattern helps teams keep code focused and recoveries snappy. Keep the example straightforward so other services can use the same interface without guessing about parameters. Keep the call site tiny and pass only `text` (string). This makes it easy to keep interfaces stable while deployments stay streamlined. Start by validating inputs and forwarding the request. If the response is successful, return the parsed result; otherwise, raise an error and log the failure. This pattern helps teams keep code focused and recoveries snappy. Keep the example straightforward so other services can use the same interface without guessing about parameters. Keep the call site tiny and pass only `text` (string). This makes it easy to keep interfaces stable while deployments